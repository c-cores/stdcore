/*
 * vector.h
 * Blaze Game Engine v0.11
 *
 * Created by Ned Bingham on December 7, 2011.
 * Modified by Ned Bingham on June 10, 2012.
 * Copyright 2011 Sol Union. All rights reserved.
 *
 * Blaze Game Engine v0.11 is free software: you can redistribute
 * it and/or modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Blaze Game Engine v0.11 is distributed in the hope that it will
 * be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Blaze Game Engine v0.11.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#include "math.h"
#include "file.h"
#include <stdarg.h>

#ifndef vector_h
#define vector_h

namespace core
{

template <class t, int s>
struct vector
{
	vector()
	{
	}

	template <class t2>
	vector(const t2 v[s])
	{
		for (int i = 0; i < s; i++)
			elems[i] = (t)v[i];
	}

	template <class t2, int s2>
	vector(vector<t2, s2> v)
	{
		int m = min(s, s2);
		for (int i = 0; i < m; i++)
			elems[i] = (t)v.elems[i];
		for (int i = m; i < s; i++)
			elems[i] = 0;
	}

	vector(int first, ...)
	{
		va_list arguments;
		int i;

		va_start(arguments, first);
		this->elems[0] = (t)first;
		for (i = 1; i < s; i++)
			this->elems[i] = (t)va_arg(arguments, int);
		va_end(arguments);
	}

	vector(double first, ...)
	{
		va_list arguments;
		int i;

		va_start(arguments, first);
		this->elems[0] = (t)first;
		for (i = 1; i < s; i++)
			this->elems[i] = (t)va_arg(arguments, double);
		va_end(arguments);
	}

	vector(float first, ...)
	{
		va_list arguments;
		int i;

		va_start(arguments, first);
		this->elems[0] = (t)first;
		for (i = 1; i < s; i++)
			this->elems[i] = (t)va_arg(arguments, double);
		va_end(arguments);
	}

	~vector()
	{
	}

	t elems[s];

	template <class t2>
	operator vector<t2, s>()
	{
		vector<t2, s> ret;
		for (int i = 0; i < s; i++)
			ret[i] = (t2)elems[i];
		return ret;
	}

	template <class t2, int s2>
	vector<t, s> &operator=(vector<t2, s2> v)
	{
		int m = min(s, s2);
		for (int i = 0; i < m; i++)
			elems[i] = (t)v.elems[i];
		for (int i = m; i < s; i++)
			elems[i] = 0;
		return *this;
	}

	template <class t2, int s2>
	vector<t, s> &operator=(const t2 v[s2])
	{
		int m = min(s, s2);
		for (int i = 0; i < m; i++)
			elems[i] = v[i];
		for (int i = m; i < s; i++)
			elems[i] = 0;
		return *this;
	}

	template <class t2>
	vector<t, s> &operator+=(vector<t2, s> v)
	{
		for (int i = 0; i < s; i++)
			elems[i] += v[i];
		return *this;
	}

	template <class t2>
	vector<t, s> &operator-=(vector<t2, s> v)
	{
		for (int i = 0; i < s; i++)
			elems[i] -= v[i];
		return *this;
	}

	template <class t2>
	vector<t, s> &operator*=(vector<t2, s> v)
	{
		for (int i = 0; i < s; i++)
			elems[i] *= v[i];
		return *this;
	}

	template <class t2>
	vector<t, s> &operator/=(vector<t2, s> v)
	{
		for (int i = 0; i < s; i++)
			elems[i] /= v[i];
		return *this;
	}

	vector<t, s> &operator+=(t f)
	{
		for (int i = 0; i < s; i++)
			elems[i] += f;
		return *this;
	}

	vector<t, s> &operator-=(t f)
	{
		for (int i = 0; i < s; i++)
			elems[i] -= f;
		return *this;
	}

	vector<t, s> &operator*=(t f)
	{
		for (int i = 0; i < s; i++)
			elems[i] *= f;
		return *this;
	}

	vector<t, s> &operator/=(t f)
	{
		for (int i = 0; i < s; i++)
			elems[i] /= f;
		return *this;
	}

	vector<t, s> operator()(int a, int b) const
	{
		vector<t, s> result;
		for (int i = a; i < b; i++)
			result.elems[i-a] = elems[i];
		for (int i = b-a; i < s; i++)
			result[i] = 0;
		return result;
	}

	template <int s2>
	void set(int a, int b, vector<t, s2> v)
	{
		for (int i = a; i < b; i++)
			elems[i] = v.elems[i-a];
	}

	t &operator[](int index)
	{
		return elems[index];
	}

	t operator[](int index) const
	{
		return elems[index];
	}

	vector<t, s> &swap(int a, int b)
	{
		t temp = elems[a];
		elems[a] = elems[b];
		elems[b] = temp;
		return *this;
	}

	template <class t2>
	void fill(t2 v)
	{
		int i;

		for (i = 0; i < s; i++)
			elems[i] = (t)v;
	}

	t *data()
	{
		return (t*)elems;
	}
};

template <class t, int s>
file &operator<<(file &f, vector<t, s> v)
{
	f << "[";
	for (int i = 0; i < s; i++)
	{
		if (i != 0)
			f << " ";
		f << v[i];
	}
	f << "]";
	return f;
}

/* negation
 *
 * negates each of v components and returns
 * the resulting vector.
 */
template <class t, int s>
vector<t, s> operator-(vector<t, s> v)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = -v.elems[i];

	return result;
}

/* vector division
 *
 * Returns the resulting vector generated by taking each of
 * v1's components and adding it to the corresponding component
 * of v2.
 */
template <class t1, class t2, int s1, int s2>
vector<t1, (s1 > s2 ? s1 : s2)> operator+(vector<t1, s1> v1, vector<t2, s2> v2)
{
	vector<t1, (s1 > s2 ? s1 : s2)> result;

	int m = min(s1, s2);
	for (int i = 0; i < m; i++)
		result.elems[i] = v1.elems[i] + v2.elems[i];
	for (int i = m; i < s1; i++)
		result.elems[i] = v1.elems[i];
	for (int i = m; i < s2; i++)
		result.elems[i] = v2.elems[i];

	return result;
}

/* vector division
 *
 * Returns the resulting vector generated by taking each of
 * v2's components and subtracting it from the corresponding component
 * of v1.
 */
template <class t1, class t2, int s1, int s2>
vector<t1, (s1 > s2 ? s1 : s2)> operator-(vector<t1, s1> v1, vector<t2, s2> v2)
{
	vector<t1, (s1 > s2 ? s1 : s2)> result;

	int m = min(s1, s2);
	for (int i = 0; i < (s1 < s2 ? s1 : s2); i++)
		result.elems[i] = v1.elems[i] - v2.elems[i];
	for (int i = m; i < s1; i++)
		result.elems[i] = v1.elems[i];
	for (int i = m; i < s2; i++)
		result.elems[i] = -v2.elems[i];

	return result;
}

/* vector multiplication
 *
 * Returns the resulting vector generated by taking each of
 * v1's components and multiplying it by the corresponding component
 * of v2.
 */
template <class t1, class t2, int s1, int s2>
vector<t1, (s1 < s2 ? s1 : s2)> operator*(vector<t1, s1> v1, vector<t2, s2> v2)
{
	vector<t1, (s1 < s2 ? s1 : s2)> result;

	int m = min(s1, s2);
	for (int i = 0; i < m; i++)
		result.elems[i] = v1.elems[i] * v2.elems[i];

	return result;
}

/* vector division
 *
 * Returns the resulting vector generated by taking each of
 * v1's components and dividing it by the corresponding component
 * of v2.
 */
template <class t1, class t2, int s1, int s2>
vector<t1, (s1 < s2 ? s1 : s2)> operator/(vector<t1, s1> v1, vector<t2, s2> v2)
{
	vector<t1, (s1 < s2 ? s1 : s2)> result;
	int m = min(s1, s2);

	for (int i = 0; i < m; i++)
		result.elems[i] = v1.elems[i] / v2.elems[i];

	return result;
}

/* scalar-vector addition
 *
 * This creates a vector who's components are f plus by the
 * corresponding component in the vector v.
 */
template <class t, int s>
vector<t, s> operator+(t f, vector<t, s> v)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = f + v.elems[i];

	return result;
}

/* scalar-vector subtraction
 *
 * This creates a vector who's components are f minus by the
 * corresponding component in the vector v.
 */
template <class t, int s>
vector<t, s> operator-(t f, vector<t, s> v)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = f - v.elems[i];

	return result;
}

/* scalar-vector multiplication
 *
 * This creates a vector who's components are f multiplied by
 * the corresponding component in the vector v.
 */
template <class t, int s>
vector<t, s> operator*(t f, vector<t, s> v)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = f * v.elems[i];

	return result;
}

/* scalar-vector division
 *
 * This creates a vector who's components are f divided by the
 * corresponding component in the vector v.
 */
template <class t, int s>
vector<t, s> operator/(t f, vector<t, s> v)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = f / v.elems[i];

	return result;
}

/* vector-scalar addition
 *
 * Adds f to all of the components of v.
 */
template <class t, int s>
vector<t, s> operator+(vector<t, s> v, t f)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = v.elems[i] + f;

	return result;
}

/* vector-scalar subtraction
 *
 * Subtracts f from all of the components of v.
 */
template <class t, int s>
vector<t, s> operator-(vector<t, s> v, t f)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = v.elems[i] - f;

	return result;
}

// vector-scalar multiplication
template <class t, int s>
vector<t, s> operator*(vector<t, s> v, t f)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = v.elems[i] * f;

	return result;
}

// vector-scalar division
template <class t, int s>
vector<t, s> operator/(vector<t, s> v, t f)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = v.elems[i] / f;

	return result;
}

// vector-vector comparison
template <class t, class t2, int s, int s2>
bool operator==(vector<t, s> v, vector<t2, s2> v2)
{
	bool result = true;
	int m = min(s, s2);

	for (int i = 0; i < m; i++)
		result = result && v[i] == v2[i];
	for (int i = m; i < s; i++)
		result = result && v[i] == 0;
	for (int i = m; i < s2; i++)
		result = result && v2[i] == 0;

	return result;
}

// vector-vector comparison
template <class t, class t2, int s, int s2>
bool operator!=(vector<t, s> v, vector<t2, s2> v2)
{
	bool result = false;
	int m = min(s, s2);

	for (int i = 0; i < m; i++)
		result = result || v[i] != v2[i];
	for (int i = m; i < s; i++)
		result = result || v[i] != 0;
	for (int i = m; i < s2; i++)
		result = result || v2[i] != 0;

	return result;
}

/* abs
 * (absolute value)
 *
 * This function takes the absolute value of each component in
 * a vector and returns the result.
 */
template <class t, int s>
vector<t, s> abs(vector<t, s> v)
{
	vector<t, s> result;

	for (int i = 0; i < s; i++)
		result.elems[i] = abs(v.elems[i]);

	return result;
}

/* norm
 * (normalize)
 *
 * This function returns the normal of a vector
 * n = v/|v|
 */
template <class t, int s>
vector<t, s> norm(vector<t, s> v)
{
	return v/mag(v);
}

/* cross
 * (cross product)
 *
 * Generates the three dimensional cross product of two vectors and returns
 * the resultant vector. (x, y, z)
 */
template <class t1, class t2>
vector<t1, 3> cross(vector<t1, 3> v1, vector<t2, 3> v2)
{
	vector<t1, 3> result;

	result.elems[0] = v1.elems[1]*v2.elems[2] - v1.elems[2]*v2.elems[1];
	result.elems[1] = v1.elems[2]*v2.elems[0] - v1.elems[0]*v2.elems[2];
	result.elems[2] = v1.elems[0]*v2.elems[1] - v1.elems[1]*v2.elems[0];

	return result;
}

/* cross
 * (cross product)
 *
 * Generates the three dimensional cross product of two vectors and returns
 * the resultant vector in homogeneous coordinates. (x, y, z, 1.0)
 */
template <class t1, class t2>
vector<t1, 4> cross(vector<t1, 4> v1, vector<t2, 4> v2)
{
	vector<t1, 4> result;

	result.elems[0] = v1.elems[1]*v2.elems[2] - v1.elems[2]*v2.elems[1];
	result.elems[1] = v1.elems[2]*v2.elems[0] - v1.elems[0]*v2.elems[2];
	result.elems[2] = v1.elems[0]*v2.elems[1] - v1.elems[1]*v2.elems[0];
	result.elems[3] = (t1)1;

	return result;
}

/* cross
 * (cross product)
 *
 * Generates the four dimensional cross product of three vectors and returns
 * the resultant vector. (x, y, z, w)
 */
template <class t1, class t2, class t3>
vector<t1, 4> cross(vector<t1, 4> v1, vector<t2, 4> v2, vector<t3, 4> v3)
{
	vector<t1, 4> result;

	result.elems[0] =  v1.elems[1]*(v2.elems[2]*v3.elems[3] - v3.elems[2]*v2.elems[3]) - v1.elems[2]*(v2.elems[1]*v3.elems[3] - v3.elems[1]*v2.elems[3]) + v1.elems[3]*(v2.elems[1]*v3.elems[2] - v3.elems[1]*v2.elems[2]);
	result.elems[1] = -v1.elems[0]*(v2.elems[2]*v3.elems[3] - v3.elems[2]*v2.elems[3]) + v1.elems[2]*(v2.elems[0]*v3.elems[3] - v3.elems[0]*v2.elems[3]) - v1.elems[3]*(v2.elems[0]*v3.elems[2] - v3.elems[0]*v2.elems[2]);
	result.elems[2] =  v1.elems[0]*(v2.elems[1]*v3.elems[3] - v3.elems[1]*v2.elems[3]) - v1.elems[1]*(v2.elems[0]*v3.elems[3] - v3.elems[0]*v2.elems[3]) + v1.elems[3]*(v2.elems[0]*v3.elems[1] - v3.elems[0]*v2.elems[1]);
	result.elems[3] = -v1.elems[0]*(v2.elems[1]*v3.elems[2] - v3.elems[1]*v2.elems[2]) + v1.elems[1]*(v2.elems[0]*v3.elems[2] - v3.elems[0]*v2.elems[2]) - v1.elems[2]*(v2.elems[0]*v3.elems[1] - v3.elems[0]*v2.elems[1]);

	return result;
}

/* cross
 * (cross product)
 *
 * Generates the four dimensional cross product of three vectors and returns
 * the result in homogeneous coordinates. (x, y, z, w, 1.0)
 */
template <class t1, class t2, class t3>
vector<t1, 5> cross(vector<t1, 5> v1, vector<t2, 5> v2, vector<t3, 5> v3)
{
	vector<t1, 5> result;

	result.elems[0] =  v1.elems[1]*(v2.elems[2]*v3.elems[3] - v3.elems[2]*v2.elems[3]) - v1.elems[2]*(v2.elems[1]*v3.elems[3] - v3.elems[1]*v2.elems[3]) + v1.elems[3]*(v2.elems[1]*v3.elems[2] - v3.elems[1]*v2.elems[2]);
	result.elems[1] = -v1.elems[0]*(v2.elems[2]*v3.elems[3] - v3.elems[2]*v2.elems[3]) + v1.elems[2]*(v2.elems[0]*v3.elems[3] - v3.elems[0]*v2.elems[3]) - v1.elems[3]*(v2.elems[0]*v3.elems[2] - v3.elems[0]*v2.elems[2]);
	result.elems[2] =  v1.elems[0]*(v2.elems[1]*v3.elems[3] - v3.elems[1]*v2.elems[3]) - v1.elems[1]*(v2.elems[0]*v3.elems[3] - v3.elems[0]*v2.elems[3]) + v1.elems[3]*(v2.elems[0]*v3.elems[1] - v3.elems[0]*v2.elems[1]);
	result.elems[3] = -v1.elems[0]*(v2.elems[1]*v3.elems[2] - v3.elems[1]*v2.elems[2]) + v1.elems[1]*(v2.elems[0]*v3.elems[2] - v3.elems[0]*v2.elems[2]) - v1.elems[2]*(v2.elems[0]*v3.elems[1] - v3.elems[0]*v2.elems[1]);
	result.elems[4] = (t1)1;

	return result;
}

/* rot
 * (rotate)
 *
 * This rotates a vector v by an angle of a around the axes
 * that aren't referenced by i and j. So in three space, where
 * x = 0, y = 1, z = 2, ..., if i = y and j = z, then we are
 * rotating around the x axis. If i = x and j = z, then we are
 * rotating around the y axis. If i = x and j = y, then we are
 * rotating around the z axis.
 */
template <class t, int s>
vector<t, s> rotate(vector<t, s> v, double a, int i, int j)
{
	vector<t, s> result = v;

	result.elems[i] = v.elems[i]*cos(a) - v.elems[j]*sin(a);
	result.elems[j] = v.elems[i]*sin(a) + v.elems[j]*cos(a);

	return result;
}

/* ror
 * (rotate right)
 *
 * This rotates a vector by the given euler angles defined
 * in a. First, it rotates around the x axis, then the y axis,
 * and so on.
 *
 * x, y, z, ...
 */
template <class t, class at, int s>
vector<t, s> rotate_xyz(vector<t, s> v, vector<at, s> a)
{
	vector<t, s> x = v;
	vector<t, s> y;

	y.elems[1] = x.elems[1]*cos(a.elems[0]) - x.elems[2]*sin(a.elems[0]);
	y.elems[2] = x.elems[1]*sin(a.elems[0]) + x.elems[2]*cos(a.elems[0]);
	y.elems[0] = x.elems[0];

	x.elems[2] = y.elems[2]*cos(a.elems[1]) - y.elems[0]*sin(a.elems[1]);
	x.elems[0] = y.elems[2]*sin(a.elems[1]) + y.elems[0]*cos(a.elems[1]);
	x.elems[1] = y.elems[1];

	y.elems[0] = x.elems[0]*cos(a.elems[2]) - x.elems[1]*sin(a.elems[2]);
	y.elems[1] = x.elems[0]*sin(a.elems[2]) + x.elems[1]*cos(a.elems[2]);
	y.elems[2] = x.elems[2];

	return y;
}

/* rol
 * (rotate left)
 *
 * This rotates a vector by the given euler angles defined
 * in a. This rotates in the reverse order of ror.
 *
 * ..., z, y, x
 */
template <class t, class at, int s>
vector<t, s> rotate_zyx(vector<t, s> v, vector <at, s> a)
{
	vector<t, s> x = v;
	vector<t, s> y;

	y.elems[0] = x.elems[0]*cos(a[2]) - x.elems[1]*sin(a[2]);
	y.elems[1] = x.elems[0]*sin(a[2]) + x.elems[1]*cos(a[2]);
	y.elems[2] = x.elems[2];

	x.elems[2] = y.elems[2]*cos(a[1]) - y.elems[0]*sin(a[1]);
	x.elems[0] = y.elems[2]*sin(a[1]) + y.elems[0]*cos(a[1]);
	x.elems[1] = y.elems[1];

	y.elems[1] = x.elems[1]*cos(a[0]) - x.elems[2]*sin(a[0]);
	y.elems[2] = x.elems[1]*sin(a[0]) + x.elems[2]*cos(a[0]);
	y.elems[0] = x.elems[0];

	return y;
}

/* slerp
 * (spherical linear interpolation)
 *
 * This calculates a spherical linear interpolation between two
 * vectors v1 and v2 using p as the percentage angle from v1 to
 * v2.
 */
template <class t, int s>
vector<t, s> slerp(vector<t, s> v1, vector<t, s> v2, t p)
{
	t omega = acos(dot(v1, v2));
	if (abs(omega) < 0.000001)
		return v1;
	t somega = sin(omega);
	vector <t, s> ret = v1*(t)sin(omega - p*omega) + v2*(t)sin(p*omega);
	return ret/somega;
}

/* mag
 * (magnitude)
 *
 * Calculates the magnitude of a vector v
 * |v| = sqrt(v夫)
 */
template <class t, int s>
t mag(vector<t, s> v)
{
	return sqrt(mag2(v));
}

/* mag2
 * (magnitude^2)
 *
 * Calculates the squared magnitude of a vector v
 * |v|^2 = v夫
 */
template <class t, int s>
t mag2(vector<t, s> v)
{
	t m = 0;
	for (int i = 0; i < s; i++)
		m += v.elems[i]*v.elems[i];
	return m;
}

/* mag2
 * (magnitude^2)
 *
 * Calculates the squared magnitude of a vector v
 * |v|^2 = v夫
 */
template <class t>
t mag2(vector<t, 2> v)
{
	return v.elems[0]*v.elems[0] + v.elems[1]*v.elems[1];
}

/* mag2
 * (magnitude^2)
 *
 * Calculates the squared magnitude of a vector v
 * |v|^2 = v夫
 */
template <class t>
t mag2(vector<t, 3> v)
{
	return v.elems[0]*v.elems[0] + v.elems[1]*v.elems[1] + v.elems[2]*v.elems[2];
}

/* mag2
 * (magnitude^2)
 *
 * Calculates the squared magnitude of a vector v
 * |v|^2 = v夫
 */
template <class t>
t mag2(vector<t, 4> v)
{
	return v.elems[0]*v.elems[0] + v.elems[1]*v.elems[1] + v.elems[2]*v.elems[2] + v.elems[3]*v.elems[3];
}

/* dot
 * (dot product)
 *
 * Calculates the dot product of two vectors v1 and v2
 * v1夫2 = (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z + ...)
 */
template <class t1, class t2, int s1, int s2>
t1 dot(vector<t1, s1> v1, vector<t2, s2> v2)
{
	t1 result = 0;

	int m = min(s1, s2);
	for (int i = 0; i < m; i++)
		result += v1.elems[i]*v2.elems[i];
	return result;
}

/* dist
 * (distance)
 *
 * Calculates the distance between two vectors v1 and v2
 * |v2 - v1| = sqrt((v2.x - v1.x)^2 + (v2.y - v1.y)^2 + (v2.z - v1.z)^2 + ...)
 */
template <class t1, class t2, int s>
t1 dist(vector<t1, s> v1, vector<t2, s> v2)
{
	return mag(v1 - v2);
}

/* dist2
 * (distance^2)
 *
 * Calculates the squared distance between two vectors v1 and v2
 * |v2 - v1|^2 = ((v2.x - v1.x)^2 + (v2.y - v1.y)^2 + (v2.z - v1.z)^2 + ...)
 */
template <class t1, class t2, int s>
t1 dist2(vector<t1, s> v1, vector<t2, s> v2)
{
	return mag2(v1 - v2);
}

/* dir
 * (direction)
 *
 * Generates a normalized direction vector pointing from v1 to v2.
 * (v2 - v1)/|v2 - v1|
 */
template <class t1, class t2, int s>
vector<t1, s> dir(vector<t1, s> v1, vector<t2, s> v2)
{
	return (-v1 + v2)/dist(v1, v2);
}

/* clamp
 * (clamp)
 *
 * Clamp all values in the vector to within the range [low,high].
 */
template <class t, int s>
vector<t, s> clamp(vector<t, s> v, t low, t high)
{
	for (int i = 0; i < s; i++)
	{
		if (v[i] < low)
			v[i] = low;
		else if (v[i] > high)
			v[i] = high;
	}
	return v;
}

}

#endif
